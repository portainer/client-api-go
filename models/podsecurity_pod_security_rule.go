// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// PodsecurityPodSecurityRule podsecurity pod security rule
//
// swagger:model podsecurity.PodSecurityRule
type PodsecurityPodSecurityRule struct {

	// allow flex volumes
	AllowFlexVolumes *PodsecurityPodSecurityAllowFlexVolumes `json:"allowFlexVolumes,omitempty"`

	// allow privilege escalation
	AllowPrivilegeEscalation *PodsecurityPodSecurityAllowPrivilegeEscalation `json:"allowPrivilegeEscalation,omitempty"`

	// allow proc mount
	AllowProcMount *PodsecurityPodSecurityAllowProcMount `json:"allowProcMount,omitempty"`

	// app armor
	AppArmor *PodsecurityPodSecurityAppArmour `json:"appArmor,omitempty"`

	// capabilities
	Capabilities *PodsecurityPodSecurityCapabilities `json:"capabilities,omitempty"`

	// enabled
	Enabled bool `json:"enabled,omitempty"`

	// end point ID
	EndPointID int64 `json:"endPointID,omitempty"`

	// forbidden sysctls list
	ForbiddenSysctlsList *PodsecurityPodSecurityForbiddenSysctlsList `json:"forbiddenSysctlsList,omitempty"`

	// host filesystem
	HostFilesystem *PodsecurityPodSecurityHostFilesystem `json:"hostFilesystem,omitempty"`

	// host namespaces
	HostNamespaces *PodsecurityPodSecurityHostNamespaces `json:"hostNamespaces,omitempty"`

	// host ports
	HostPorts *PodsecurityPodSecurityHostNetworkingPorts `json:"hostPorts,omitempty"`

	// id
	ID int64 `json:"id,omitempty"`

	// privileged containers
	PrivilegedContainers *PodsecurityPodSecurityPrivilegedContainers `json:"privilegedContainers,omitempty"`

	// read only root file system
	ReadOnlyRootFileSystem *PodsecurityPodSecurityReadOnlyRootFileSystem `json:"readOnlyRootFileSystem,omitempty"`

	// sec comp
	SecComp *PodsecurityPodSecuritySecComp `json:"secComp,omitempty"`

	// selinux
	Selinux *PodsecurityPodSecuritySelinux `json:"selinux,omitempty"`

	// users
	Users *PodsecurityPodSecurityUsers `json:"users,omitempty"`

	// volume types
	VolumeTypes *PodsecurityPodSecurityVolumeTypes `json:"volumeTypes,omitempty"`
}

// Validate validates this podsecurity pod security rule
func (m *PodsecurityPodSecurityRule) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAllowFlexVolumes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAllowPrivilegeEscalation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAllowProcMount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAppArmor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCapabilities(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateForbiddenSysctlsList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHostFilesystem(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHostNamespaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHostPorts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrivilegedContainers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReadOnlyRootFileSystem(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecComp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelinux(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumeTypes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PodsecurityPodSecurityRule) validateAllowFlexVolumes(formats strfmt.Registry) error {
	if swag.IsZero(m.AllowFlexVolumes) { // not required
		return nil
	}

	if m.AllowFlexVolumes != nil {
		if err := m.AllowFlexVolumes.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("allowFlexVolumes")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("allowFlexVolumes")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) validateAllowPrivilegeEscalation(formats strfmt.Registry) error {
	if swag.IsZero(m.AllowPrivilegeEscalation) { // not required
		return nil
	}

	if m.AllowPrivilegeEscalation != nil {
		if err := m.AllowPrivilegeEscalation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("allowPrivilegeEscalation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("allowPrivilegeEscalation")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) validateAllowProcMount(formats strfmt.Registry) error {
	if swag.IsZero(m.AllowProcMount) { // not required
		return nil
	}

	if m.AllowProcMount != nil {
		if err := m.AllowProcMount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("allowProcMount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("allowProcMount")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) validateAppArmor(formats strfmt.Registry) error {
	if swag.IsZero(m.AppArmor) { // not required
		return nil
	}

	if m.AppArmor != nil {
		if err := m.AppArmor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("appArmor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("appArmor")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) validateCapabilities(formats strfmt.Registry) error {
	if swag.IsZero(m.Capabilities) { // not required
		return nil
	}

	if m.Capabilities != nil {
		if err := m.Capabilities.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capabilities")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capabilities")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) validateForbiddenSysctlsList(formats strfmt.Registry) error {
	if swag.IsZero(m.ForbiddenSysctlsList) { // not required
		return nil
	}

	if m.ForbiddenSysctlsList != nil {
		if err := m.ForbiddenSysctlsList.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("forbiddenSysctlsList")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("forbiddenSysctlsList")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) validateHostFilesystem(formats strfmt.Registry) error {
	if swag.IsZero(m.HostFilesystem) { // not required
		return nil
	}

	if m.HostFilesystem != nil {
		if err := m.HostFilesystem.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hostFilesystem")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("hostFilesystem")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) validateHostNamespaces(formats strfmt.Registry) error {
	if swag.IsZero(m.HostNamespaces) { // not required
		return nil
	}

	if m.HostNamespaces != nil {
		if err := m.HostNamespaces.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hostNamespaces")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("hostNamespaces")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) validateHostPorts(formats strfmt.Registry) error {
	if swag.IsZero(m.HostPorts) { // not required
		return nil
	}

	if m.HostPorts != nil {
		if err := m.HostPorts.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hostPorts")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("hostPorts")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) validatePrivilegedContainers(formats strfmt.Registry) error {
	if swag.IsZero(m.PrivilegedContainers) { // not required
		return nil
	}

	if m.PrivilegedContainers != nil {
		if err := m.PrivilegedContainers.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("privilegedContainers")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("privilegedContainers")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) validateReadOnlyRootFileSystem(formats strfmt.Registry) error {
	if swag.IsZero(m.ReadOnlyRootFileSystem) { // not required
		return nil
	}

	if m.ReadOnlyRootFileSystem != nil {
		if err := m.ReadOnlyRootFileSystem.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("readOnlyRootFileSystem")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("readOnlyRootFileSystem")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) validateSecComp(formats strfmt.Registry) error {
	if swag.IsZero(m.SecComp) { // not required
		return nil
	}

	if m.SecComp != nil {
		if err := m.SecComp.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("secComp")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("secComp")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) validateSelinux(formats strfmt.Registry) error {
	if swag.IsZero(m.Selinux) { // not required
		return nil
	}

	if m.Selinux != nil {
		if err := m.Selinux.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("selinux")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("selinux")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) validateUsers(formats strfmt.Registry) error {
	if swag.IsZero(m.Users) { // not required
		return nil
	}

	if m.Users != nil {
		if err := m.Users.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("users")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("users")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) validateVolumeTypes(formats strfmt.Registry) error {
	if swag.IsZero(m.VolumeTypes) { // not required
		return nil
	}

	if m.VolumeTypes != nil {
		if err := m.VolumeTypes.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volumeTypes")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("volumeTypes")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this podsecurity pod security rule based on the context it is used
func (m *PodsecurityPodSecurityRule) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAllowFlexVolumes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAllowPrivilegeEscalation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAllowProcMount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAppArmor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCapabilities(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateForbiddenSysctlsList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHostFilesystem(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHostNamespaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHostPorts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrivilegedContainers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReadOnlyRootFileSystem(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSecComp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelinux(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumeTypes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PodsecurityPodSecurityRule) contextValidateAllowFlexVolumes(ctx context.Context, formats strfmt.Registry) error {

	if m.AllowFlexVolumes != nil {
		if err := m.AllowFlexVolumes.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("allowFlexVolumes")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("allowFlexVolumes")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) contextValidateAllowPrivilegeEscalation(ctx context.Context, formats strfmt.Registry) error {

	if m.AllowPrivilegeEscalation != nil {
		if err := m.AllowPrivilegeEscalation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("allowPrivilegeEscalation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("allowPrivilegeEscalation")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) contextValidateAllowProcMount(ctx context.Context, formats strfmt.Registry) error {

	if m.AllowProcMount != nil {
		if err := m.AllowProcMount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("allowProcMount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("allowProcMount")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) contextValidateAppArmor(ctx context.Context, formats strfmt.Registry) error {

	if m.AppArmor != nil {
		if err := m.AppArmor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("appArmor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("appArmor")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) contextValidateCapabilities(ctx context.Context, formats strfmt.Registry) error {

	if m.Capabilities != nil {
		if err := m.Capabilities.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capabilities")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capabilities")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) contextValidateForbiddenSysctlsList(ctx context.Context, formats strfmt.Registry) error {

	if m.ForbiddenSysctlsList != nil {
		if err := m.ForbiddenSysctlsList.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("forbiddenSysctlsList")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("forbiddenSysctlsList")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) contextValidateHostFilesystem(ctx context.Context, formats strfmt.Registry) error {

	if m.HostFilesystem != nil {
		if err := m.HostFilesystem.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hostFilesystem")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("hostFilesystem")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) contextValidateHostNamespaces(ctx context.Context, formats strfmt.Registry) error {

	if m.HostNamespaces != nil {
		if err := m.HostNamespaces.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hostNamespaces")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("hostNamespaces")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) contextValidateHostPorts(ctx context.Context, formats strfmt.Registry) error {

	if m.HostPorts != nil {
		if err := m.HostPorts.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hostPorts")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("hostPorts")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) contextValidatePrivilegedContainers(ctx context.Context, formats strfmt.Registry) error {

	if m.PrivilegedContainers != nil {
		if err := m.PrivilegedContainers.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("privilegedContainers")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("privilegedContainers")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) contextValidateReadOnlyRootFileSystem(ctx context.Context, formats strfmt.Registry) error {

	if m.ReadOnlyRootFileSystem != nil {
		if err := m.ReadOnlyRootFileSystem.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("readOnlyRootFileSystem")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("readOnlyRootFileSystem")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) contextValidateSecComp(ctx context.Context, formats strfmt.Registry) error {

	if m.SecComp != nil {
		if err := m.SecComp.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("secComp")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("secComp")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) contextValidateSelinux(ctx context.Context, formats strfmt.Registry) error {

	if m.Selinux != nil {
		if err := m.Selinux.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("selinux")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("selinux")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) contextValidateUsers(ctx context.Context, formats strfmt.Registry) error {

	if m.Users != nil {
		if err := m.Users.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("users")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("users")
			}
			return err
		}
	}

	return nil
}

func (m *PodsecurityPodSecurityRule) contextValidateVolumeTypes(ctx context.Context, formats strfmt.Registry) error {

	if m.VolumeTypes != nil {
		if err := m.VolumeTypes.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volumeTypes")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("volumeTypes")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PodsecurityPodSecurityRule) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PodsecurityPodSecurityRule) UnmarshalBinary(b []byte) error {
	var res PodsecurityPodSecurityRule
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
