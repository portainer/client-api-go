// Code generated by go-swagger; DO NOT EDIT.

package cli

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/portainer/client-api-go/v2/models"
	"github.com/spf13/cobra"
)

// Schema cli for ReleaseLock

// register flags to command
func registerModelReleaseLockFlags(depth int, cmdPrefix string, cmd *cobra.Command) error {

	if err := registerReleaseLockDependencies(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerReleaseLockDigest(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerReleaseLockGenerated(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	return nil
}

func registerReleaseLockDependencies(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	// warning: dependencies []*ReleaseDependency array type is not supported by go-swagger cli yet

	return nil
}

func registerReleaseLockDigest(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	digestDescription := `Digest is a hash of the dependencies in Chart.yaml.`

	var digestFlagName string
	if cmdPrefix == "" {
		digestFlagName = "digest"
	} else {
		digestFlagName = fmt.Sprintf("%v.digest", cmdPrefix)
	}

	var digestFlagDefault string

	_ = cmd.PersistentFlags().String(digestFlagName, digestFlagDefault, digestDescription)

	return nil
}

func registerReleaseLockGenerated(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	generatedDescription := `Generated is the date the lock file was last generated.`

	var generatedFlagName string
	if cmdPrefix == "" {
		generatedFlagName = "generated"
	} else {
		generatedFlagName = fmt.Sprintf("%v.generated", cmdPrefix)
	}

	var generatedFlagDefault string

	_ = cmd.PersistentFlags().String(generatedFlagName, generatedFlagDefault, generatedDescription)

	return nil
}

// retrieve flags from commands, and set value in model. Return true if any flag is passed by user to fill model field.
func retrieveModelReleaseLockFlags(depth int, m *models.ReleaseLock, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false

	err, dependenciesAdded := retrieveReleaseLockDependenciesFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || dependenciesAdded

	err, digestAdded := retrieveReleaseLockDigestFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || digestAdded

	err, generatedAdded := retrieveReleaseLockGeneratedFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || generatedAdded

	return nil, retAdded
}

func retrieveReleaseLockDependenciesFlags(depth int, m *models.ReleaseLock, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	dependenciesFlagName := fmt.Sprintf("%v.dependencies", cmdPrefix)
	if cmd.Flags().Changed(dependenciesFlagName) {
		// warning: dependencies array type []*ReleaseDependency is not supported by go-swagger cli yet
	}

	return nil, retAdded
}

func retrieveReleaseLockDigestFlags(depth int, m *models.ReleaseLock, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	digestFlagName := fmt.Sprintf("%v.digest", cmdPrefix)
	if cmd.Flags().Changed(digestFlagName) {

		var digestFlagName string
		if cmdPrefix == "" {
			digestFlagName = "digest"
		} else {
			digestFlagName = fmt.Sprintf("%v.digest", cmdPrefix)
		}

		digestFlagValue, err := cmd.Flags().GetString(digestFlagName)
		if err != nil {
			return err, false
		}
		m.Digest = digestFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveReleaseLockGeneratedFlags(depth int, m *models.ReleaseLock, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	generatedFlagName := fmt.Sprintf("%v.generated", cmdPrefix)
	if cmd.Flags().Changed(generatedFlagName) {

		var generatedFlagName string
		if cmdPrefix == "" {
			generatedFlagName = "generated"
		} else {
			generatedFlagName = fmt.Sprintf("%v.generated", cmdPrefix)
		}

		generatedFlagValue, err := cmd.Flags().GetString(generatedFlagName)
		if err != nil {
			return err, false
		}
		m.Generated = generatedFlagValue

		retAdded = true
	}

	return nil, retAdded
}
